Простір імен – це «контейнер», який групує назви (змінні, функції, класи тощо).  
Використовуючи простори імен, ми **створюємо окремі області видимості**. Це допомагає уникнути конфліктів: дві бібліотеки можуть мати функцію `print()`, але якщо вони знаходяться в різних просторах імен, компілятор не працює коректно.

> **Чому це важливо?**  
> Якщо у вас є два файли з однаковим ім'ям функції, без просторів імен компілятор не зрозуміє, яку саме треба викликати. Простори імен розділяють їх на «пакети».

namespace *назва_простору_імен*
{
	*оголошення_сутностей*
}
## Коли використовувати

| Ситуація | Чому простір імен потрібен |
|----------|---------------------------|
| **Багато бібліотек** | Уникаємо конфліктів між однаковими назвами. |
| **Великий проект** | Організовуємо код у логічні блоки (наприклад, `UI`, `Network`). |
| **Публічний API** | Пакуємо функції в окремий простір імен, щоб користувачі не писали зайвих префіксів. |

## Приклади

### 1. Простий простір імен
```cpp
namespace ui{
	void print(double a,double b){
		std::cout<<"number a = "<<a<<"\n number b = "<<b<<std::endl;
	}
}
namespace log{
	void print(double a,double b){
		std::clog<<"a="<<a<<";b="<<b<<std::flush;
	}
}
int main(){
	double a=5,b=3.4;
	a=sin(b);
	ui::print(a,b);  //number a = -0.255541
	                 //number b = 3.4
	
	log::print(a,b); //a=-0.255541;b=3.4
	return 0;
}
```

### 2. Вкладені простори імен
```cpp
namespace Graphics {
    namespace Shapes {
        void drawCircle() { /* ... */ }
    }
}

int main() {
    Graphics::Shapes::drawCircle();   // Доступ до вкладеного простору
}
```

### 3. Використання `using`
```cpp
namespace Utils {
    void log(const char* msg) {}
}

using namespace Utils;   // Тепер можна викликати без префіксу

int main() {
    log("Hello");         // Відсутній префікс
}
```

> **Порада**: у великих проектах краще уникати `using namespace` в заголовкових файлах, щоб не «розпилювати» імена по всьому коду.

## Теги  
- #namespaces
- #codeorganization